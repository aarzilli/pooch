In the spirit of literate programming, here is an outline of how the code is structured.

The two main files are pooch.go and serve.go, where pooch.go implements the command line interaction and serve.go implements the http interaction.
They share many similarities: both use parse.go to interpret the user input and backend.go to manipulate the sql database. The types used throught the program are defined inside types.go along with three versions of the Entry type (Entry is the smart type, UnmarshalEntry is the one used to communicate with my javascript and CalendarEntry is the one used to communicate with the fullcalendar javascript). Some of the type conversions are specified inside parse.go instead of types.go.

There are some utility files:
* dbg.go wraps log package into something that has loglevels
* dbname.go provides some utility functions to search tasklist files on disk. The most important one is Resolve which finds a tasklist name in POOCHPATH and the current directory.

The files described here are sufficient to define the behaviour of the command line interface, except for the backwards compatibility commands which are implemented in compat.go, you should not concern yourself much with this, it's just needed to import entries from a format I used in a prototype implementation of pooch.
The Parse method in parse.go is also used to parse the legacy format, the new format, the one used in the "New entry" box on the http interface is parsed by the QuickParse function.

Serve.go is considerably more complicated. It uses staticserve.go to serve static pages from an in-memory map. This file is automatically generated by make-staticserve.pl that takes any number of files from the current directory, mime encodes them and saves them as a valid go map definition. I did this so the program didn't need to look for files on disk and once go implements static linking can be deployed as a stand-alone executable.
The other file used by serve.go is htmlformat.go, this file defines the html templates used by the http interface, this is done by using the template package.

The two interesting javascript files are int.js and cint.js which define the client side of the http interface for /list and /cal respectively. The css files are: cal.css (for /cal) and list.css and dlist.css (for /list). List and dlist are interchangeable, the first one is the default the second defines a dark theme for /list. Eventually I will include full themeing. All this files (int.js, cint.js, cal.css, list.css and dlist.css) are compiled into go with make-staticserve.pl.

The remaining files are:

* calendar.css and calendar.js -> define the date picking calendar in /list mode (taken from openjs.com, see files for credits)
* fullcalendar.css, fullcalendar.js -> implementation of the actual calendar html (taken from arshaw.com, see files for credits)
* jquery.js and jquery-ui-custom.js -> jquery, needed for fullcalendar to work (but eventually I will migrate cint.js and int.js to jquery too)
* shortcut.js -> utility to define keyboard shortcuts in javascript (taken from openjs.com, see files for credits)
* static-test.html -> a static html test file

All are compiled to go with make-staticserve.pl

