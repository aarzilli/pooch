The two main files are pooch.go and serve.go, where pooch.go implements the command line interaction and serve.go implements the http interaction.
They share many similarities: both use the same parser to interpret the user input and backend.go to manipulate the sql database. The types used throught the program are defined inside types.go along with two versions of the Entry type (Entry is the smart type and UnmarshalEntry is the one used to communicate with my javascript). Some of the type conversions are specified inside parse.go instead of types.go.

The parser itself is implemented by the files: parsetime.go (implements parsing of dates and time), tokenizer.go, pureparser.go and parserint.go. Pureparser is only concerned with the interpretation of input, parserint.go is the interface between the parser and the backend, as such also provides compilation of user input into SQL SELECT statements. Pureparser uses tokenizer.go to tokenize the input.
In detail both tokenization and parsing are implemented manually, the reason is that the parsing I need is both simple and a little out of line compared to normal programming language parsing and would be made unnecessarily hard by employing automated parser generators. The parser itself is a recursive descent parser.

There are some utility files:
* dbg.go wraps log package into something that has loglevels, plus some utilities (must, WriteStackTrace) to deal with panics and errors
* dbname.go provides some utility functions to search tasklist files on disk. The most important one is Resolve which finds a tasklist name in POOCHPATH and the current directory.

Serve.go is considerably more complicated. It uses staticserve.go to serve static pages from an in-memory map. This file is automatically generated by make-staticserve.pl that takes any number of files from the current directory, mime encodes them and saves them as a valid go map definition. I did this so the program didn't need to look for files on disk and once go implements static linking can be deployed as a stand-alone executable, it will never be deployed as such, probably, but that was the initial intention.
The other file used by serve.go is htmlformat.go, this file defines the html templates used by the http interface, this is done by using the template package.

Multiserve.go defines a multiuser interface on top of serve.go. This is the code that is running on ddzuk.dyndns.info.

The two interesting javascript files are int.js and cint.js which define the client side of the http interface for /list and /cal respectively. The css files are: cal.css (for /cal) and list.css and dlist.css (for /list). List and dlist are interchangeable, the first one is the default the second defines a dark theme for /list. Eventually I will include full themeing. All this files (int.js, cint.js, cal.css, list.css and dlist.css) are compiled into go with make-staticserve.pl.

Notable files inside static/ directory are:

* calendar.css and calendar.js -> define the date picking calendar in /list mode (taken from openjs.com, see files for credits)
* fullcalendar.css, fullcalendar.js -> implementation of the actual calendar html (taken from arshaw.com, see files for credits)
* jquery.js and jquery-ui-custom.js -> jquery, needed for fullcalendar to work (but eventually I will migrate cint.js and int.js to jquery too)
* shortcut.js -> utility to define keyboard shortcuts in javascript (taken from openjs.com, see files for credits)
* static-test.html -> a static html test file

All are compiled to go with make-staticserve.pl

Inside the directory serv/ are some configuration files used by the installation at ddzuk.dyndns.info.

The integration with lua is done inside luaint.go, The wrapper for lua is go-lua (external dependency of this project). luaint itself is mostly used by backend.go.
