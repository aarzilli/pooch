FEATURE PLAN FOR STABLE04

SAVING QUERIES

The GUI should allow queries to be saved, with any name.

A NEW QUERY LANGUAGE

This should be supported by the backend through accepting on search() an object of interface Query, this object should be expressive enough to support the query language described here and all the queries used in the backend. This query object will have a method that will be used to compile it into a SELECT statement.

The query will be able to contain free-text, anything that doesn't match one of the patterns will be considered free text, collected and used for the full-text search. Everywhere the characters @ and # will be interchangeable.
The query will have the form of:

query ::= ([+-]<expr>)*

free text is interpreted in this context as a '+' character so:

"#tag1 some text #tag2 -#tag3" -> "#tag1 +#tag2 -#tag3" everything that doesn't have tag3 and has either tag1 or tag2 (and matches "some text")
"#tag1 #tag2 some text -#tag3" -> "#tag1#tag2 -#tag3" everything that has both tag1 and tag2 but not tag3 (and matches "some text"

Spaces are generally not significant ("#tag1 + #tag2" is equivalent to "#tag1 +#tag2")

When the query has more than one term it is expressed with this struct (if it has only one term it will be whatever that term is):

type BooleanExpr struct {
   ored []Expr      // stuff that begins with '+'
   removed []Expr   // stuff that begins with '-'
}


An expression can be a *simple tag*, like "#tag1". Simple tags can have two decorators:
- exclamation mark: #tag1! means that tag1 must be present and it's value should be shown in the interface
- question mark: #tag? means that tag1 value should be shown in the interface (when present)

simple-tag-expr ::= [#@]<tag-name>[?!]?

An expression can also be an *comparison*, this is expressed as:

comparison-expr ::= <simple-tag-expr> ("=" | "<" | ">" | "<=" | ">=" | "!=" | "=~" | "!~") <value>

=~ and !~ are the SQL LIKE and NOT LIKE operators, not the perl regex matching operators.

If <value> can be interpreted as a date it will be normalized into a date, if it can be interpreted as an number it will be converted into a number, otherwise it will be used as a string.

By default <value> will be considered ending at the first space, if <value> must contain spaces it should be surrounded by double quotes

This is represented by:

type SimpleExpr struct {
  op string  // if empty string this is a simple tag expression
  valueIsNumber bool
  name string
  value string
  numValue float// only present when the value is a number
}

Therefore:

simple-expr ::= <simple-tag-expr> | <comparison-expr> | <special-tag-expr>

We will talk later about <special-tag-expr>, suffice to say that they are just shortcuts to <simple-tag-expr>.

Now an <expr> is simply:

expr ::= <simple-expr>*

This will be represented as:

type AndExpr struct {
  subQuery []Query
}

Of course this object will be generated only if there is at least two subQuery.

PARSER

The parser will use a generalized lexer and a recursive descent parser, this will generate a Query object. The Query interface will be:

type Query interface {
  GuessCols() (cols map[string]string)
  AsAdd() (query string, cols map[string]string)
  NormalizeForSelect() Query
  AsSelect() (theselect string)
  String() string
}

GuessCols and AsAdd will be used by QuickParse for the add command. In this case no "removed" expressions will be allowed and all the SimpleExpr will need to have no operator or the "=" operator. Anything else will fail.

AsSelect will create a select statement that will return the requested documents. For this to work it will be required that

a) the top level is BooleanExpr
b) every subquery of BooleanExpr is an AndExpr
c) every subquery of AndExpr is a SimpleExpr

Calling NormalizeForSelect will return a Query object that satisfies this conditions, it will only work on things that the parser can produce, BooleanExpr contained inside an AndExpr will cause it to fail.

SPECIAL CASES FOR SIMPLE TAGS

The things that worked in the original version as tags expand to the reasonable thing:

 #<date> -> #when=<date>
 #<date>+<recur> - #when=<date> #recur=<recur>
 #l, #later - #priority=later
 #n, #now - #priority=now
 #d, #done - #priority=done
 #$, #N, #Notes - #priority=notes
 #$$, #StickyNotes - #priority=sticky

Two new ones should be added:

 #<date>,<time>  -> #when="<date> <time>"
 #<date>,<time>+<recur> -> #when="<date> <time>" #recur=<recur>

Note that the format <date>,<time> will also need to be supported everywhere else we parse time.

ODDS AND ENDS

Saved queries will replace the current query. The default saved query is "index" and it will wipe the current query. Query suggestion will drill down on the current query and will still be calculated as they are now (subcolumns of the active query).
For Subcols to be called the parsed expression will be required to be a SimpleQuery (same as GuessCols / AsAdd)

There needs to be a way of specifying the sort order too.

Also a way of outputting search results from the command line in a format that is easily parsed would be nice.


INTERFACE

The widget to change the 'When' column should be usable without opening the editor, all the columns visualized in the list should be editable without opening the editor.
